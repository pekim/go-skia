// This is a generated file. DO NOT EDIT.

package skia

// #cgo CXXFLAGS: -I ${SRCDIR}/_skia/skia
// #cgo LDFLAGS: -L ${SRCDIR}/_skia/build
// #cgo LDFLAGS: -l skia
// #cgo LDFLAGS: -l skshaper
// #cgo LDFLAGS: -l svg
// #cgo pkg-config: freetype2
//
// #include "api.h"
import "C"

/*
SkBitmap describes a two-dimensional raster pixel array. SkBitmap is built on
SkImageInfo, containing integer width and height, SkColorType and SkAlphaType
describing the pixel format, and SkColorSpace describing the range of colors.
SkBitmap points to SkPixelRef, which describes the physical array of pixels.
SkImageInfo bounds may be located anywhere fully inside SkPixelRef bounds.

SkBitmap can be drawn using SkCanvas. SkBitmap can be a drawing destination for SkCanvas
draw member functions. SkBitmap flexibility as a pixel container limits some
optimizations available to the target platform.

If pixel array is primarily read-only, use SkImage for better performance.
If pixel array is primarily written to, use SkSurface for better performance.

Declaring SkBitmap const prevents altering SkImageInfo: the SkBitmap height, width,
and so on cannot change. It does not affect SkPixelRef: a caller may write its
pixels. Declaring SkBitmap const affects SkBitmap configuration, not its contents.

SkBitmap is not thread safe. Each thread must have its own copy of SkBitmap fields,
although threads may share the underlying pixel array.
*/
type Bitmap struct {
	sk *C.sk_SkBitmap
}

/*
Creates an empty SkBitmap without pixels, with kUnknown_SkColorType,
kUnknown_SkAlphaType, and with a width and height of zero. SkPixelRef origin is
set to (0, 0).

Use setInfo() to associate SkColorType, SkAlphaType, width, and height
after SkBitmap has been created.

@return  empty SkBitmap

example: https://fiddle.skia.org/c/@Bitmap_empty_constructor
*/
func NewBitmap() Bitmap {

	retC := C.misk_new_Bitmap()
	return Bitmap{sk: retC}
}

/*
Copies settings from src to returned SkBitmap. Shares pixels if src has pixels
allocated, so both bitmaps reference the same pixels.

@param src  SkBitmap to copy SkImageInfo, and share SkPixelRef
@return     copy of src

example: https://fiddle.skia.org/c/@Bitmap_copy_const_SkBitmap
*/
func NewBitmapCopy(src Bitmap) Bitmap {
	c_src := src.sk
	retC := C.misk_new_BitmapCopy(c_src)
	return Bitmap{sk: retC}
}

/*
Decrements SkPixelRef reference count, if SkPixelRef is not nullptr.
*/
func (o Bitmap) Delete() {
	C.misk_delete_SkBitmap(o.sk)
}

/*
Returns true if all pixels are opaque. SkColorType determines how pixels
are encoded, and whether pixel describes alpha. Returns true for SkColorType
without alpha in each pixel; for other SkColorType, returns true if all
pixels have alpha values equivalent to 1.0 or greater.

For SkColorType kRGB_565_SkColorType or kGray_8_SkColorType: always
returns true. For SkColorType kAlpha_8_SkColorType, kBGRA_8888_SkColorType,
kRGBA_8888_SkColorType: returns true if all pixel alpha values are 255.
For SkColorType kARGB_4444_SkColorType: returns true if all pixel alpha values are 15.
For kRGBA_F16_SkColorType: returns true if all pixel alpha values are 1.0 or
greater.

Returns false for kUnknown_SkColorType.

@param bm  SkBitmap to check
@return    true if all pixels have opaque values or SkColorType is opaque
*/
func BitmapComputeIsOpaque(bm Bitmap) bool {
	c_bm := bm.sk
	retC := C.misk_Bitmap_ComputeIsOpaque(c_bm)
	return bool(retC)
}

/*
SkCanvas provides an interface for drawing, and how the drawing is clipped and transformed.
SkCanvas contains a stack of SkMatrix and clip values.

SkCanvas and SkPaint together provide the state to draw into SkSurface or SkDevice.
Each SkCanvas draw call transforms the geometry of the object by the concatenation of all
SkMatrix values in the stack. The transformed geometry is clipped by the intersection
of all of clip values in the stack. The SkCanvas draw calls use SkPaint to supply drawing
state such as color, SkTypeface, text size, stroke width, SkShader and so on.

To draw to a pixel-based destination, create raster surface or GPU surface.
Request SkCanvas from SkSurface to obtain the interface to draw.
SkCanvas generated by raster surface draws to memory visible to the CPU.
SkCanvas generated by GPU surface uses Vulkan or OpenGL to draw to the GPU.

To draw to a document, obtain SkCanvas from SVG canvas, document PDF, or SkPictureRecorder.
SkDocument based SkCanvas and other SkCanvas subclasses reference SkDevice describing the
destination.

SkCanvas can be constructed to draw to SkBitmap without first creating raster surface.
This approach may be deprecated in the future.
*/
type Canvas struct {
	sk *C.sk_SkCanvas
}

/*
Creates an empty SkCanvas with no backing device or pixels, with
a width and height of zero.

@return  empty SkCanvas

example: https://fiddle.skia.org/c/@Canvas_empty_constructor
*/
func NewCanvas() Canvas {

	retC := C.misk_new_Canvas()
	return Canvas{sk: retC}
}

/*
Creates SkCanvas of the specified dimensions without a SkSurface.
Used by subclasses with custom implementations for draw member functions.

If props equals nullptr, SkSurfaceProps are created with
SkSurfaceProps::InitType settings, which choose the pixel striping
direction and order. Since a platform may dynamically change its direction when
the device is rotated, and since a platform may have multiple monitors with
different characteristics, it is best not to rely on this legacy behavior.

@param width   zero or greater
@param height  zero or greater
@param props   LCD striping orientation and setting for device independent fonts;
may be nullptr
@return        SkCanvas placeholder with dimensions

example: https://fiddle.skia.org/c/@Canvas_int_int_const_SkSurfaceProps_star
*/
func NewCanvasWithDimensions(width int, height int, props SurfaceProps) Canvas {
	c_width := C.int(width)
	c_height := C.int(height)
	c_props := props.sk
	retC := C.misk_new_CanvasWithDimensions(c_width, c_height, c_props)
	return Canvas{sk: retC}
}

/*
Constructs a canvas that draws into bitmap.
Sets kUnknown_SkPixelGeometry in constructed SkSurface.

SkBitmap is copied so that subsequently editing bitmap will not affect
constructed SkCanvas.

May be deprecated in the future.

@param bitmap  width, height, SkColorType, SkAlphaType, and pixel
storage of raster surface
@return        SkCanvas that can be used to draw into bitmap

example: https://fiddle.skia.org/c/@Canvas_copy_const_SkBitmap
*/
func NewCanvasFromBitmap(bitmap Bitmap) Canvas {
	c_bitmap := bitmap.sk
	retC := C.misk_new_CanvasFromBitmap(c_bitmap)
	return Canvas{sk: retC}
}

/*
Constructs a canvas that draws into bitmap.
Use props to match the device characteristics, like LCD striping.

bitmap is copied so that subsequently editing bitmap will not affect
constructed SkCanvas.

@param bitmap  width, height, SkColorType, SkAlphaType,
and pixel storage of raster surface
@param props   order and orientation of RGB striping; and whether to use
device independent fonts
@return        SkCanvas that can be used to draw into bitmap

example: https://fiddle.skia.org/c/@Canvas_const_SkBitmap_const_SkSurfaceProps
*/
func NewCanvasFromBitmapSurfaceProps(bitmap Bitmap, props SurfaceProps) Canvas {
	c_bitmap := bitmap.sk
	c_props := props.sk
	retC := C.misk_new_CanvasFromBitmapSurfaceProps(c_bitmap, c_props)
	return Canvas{sk: retC}
}

/*
Draws saved layers, if any.
Frees up resources used by SkCanvas.

example: https://fiddle.skia.org/c/@Canvas_destructor
*/
func (o Canvas) Delete() {
	C.misk_delete_SkCanvas(o.sk)
}

type CanvasClipEdgeStyle int64

const (
	CanvasClipEdgeStyleHard CanvasClipEdgeStyle = 0
	CanvasClipEdgeStyleSoft CanvasClipEdgeStyle = 1
)

/*
Selects if an array of points are drawn as discrete points, as lines, or as
an open polygon.
*/
type CanvasPointMode int64

const (
	// draw each point separately
	CanvasPointModePoints CanvasPointMode = 0
	// draw each pair of points as a line segment
	CanvasPointModeLines CanvasPointMode = 1
	// draw the array of points as a open polygon
	CanvasPointModePolygon CanvasPointMode = 2
)

/*
Experimental. Controls anti-aliasing of each edge of images in an image-set.
*/
type CanvasQuadAAFlags int64

const (
	CanvasQuadAAFlagsLeft_QuadAAFlag   CanvasQuadAAFlags = 1
	CanvasQuadAAFlagsTop_QuadAAFlag    CanvasQuadAAFlags = 2
	CanvasQuadAAFlagsRight_QuadAAFlag  CanvasQuadAAFlags = 4
	CanvasQuadAAFlagsBottom_QuadAAFlag CanvasQuadAAFlags = 8
	CanvasQuadAAFlagsNone              CanvasQuadAAFlags = 0
	CanvasQuadAAFlagsAll               CanvasQuadAAFlags = 15
)

/*
SaveLayerFlags provides options that may be used in any combination in SaveLayerRec,
defining how layer allocated by saveLayer() operates. It may be set to zero,
kPreserveLCDText_SaveLayerFlag, kInitWithPrevious_SaveLayerFlag, or both flags.
*/
type CanvasSaveLayerFlagsSet int64

const (
	CanvasSaveLayerFlagsSetPreserveLCDText_SaveLayerFlag CanvasSaveLayerFlagsSet = 2
	// initializes with previous contents
	CanvasSaveLayerFlagsSetInitWithPrevious_SaveLayerFlag CanvasSaveLayerFlagsSet = 4
	CanvasSaveLayerFlagsSetF16ColorType                   CanvasSaveLayerFlagsSet = 16
)

type CanvasSaveLayerStrategy int64

const (
	CanvasSaveLayerStrategyFullLayer CanvasSaveLayerStrategy = 0
	CanvasSaveLayerStrategyNoLayer   CanvasSaveLayerStrategy = 1
)

/*
SrcRectConstraint controls the behavior at the edge of source SkRect,
provided to drawImageRect() when there is any filtering. If kStrict is set,
then extra code is used to ensure it never samples outside of the src-rect.
kStrict_SrcRectConstraint disables the use of mipmaps and anisotropic filtering.
*/
type CanvasSrcRectConstraint int64

const (
	// sample only inside bounds; slower
	CanvasSrcRectConstraintStrict CanvasSrcRectConstraint = 0
	// sample outside bounds; faster
	CanvasSrcRectConstraintFast CanvasSrcRectConstraint = 1
)

type ColorSpace struct {
	sk *C.sk_SkColorSpace
}

/*
Create the sRGB color space.
*/
func ColorSpaceMakeSRGB() ColorSpace {

	retC := C.misk_ColorSpace_MakeSRGB()
	return ColorSpace{sk: retC}
}

/*
Colorspace with the sRGB primaries, but a linear (1.0) gamma.
*/
func ColorSpaceMakeSRGBLinear() ColorSpace {

	retC := C.misk_ColorSpace_MakeSRGBLinear()
	return ColorSpace{sk: retC}
}

/*
If both are null, we return true. If one is null and the other is not, we return false.
If both are non-null, we do a deeper compare.
*/
func ColorSpaceEquals(p0 ColorSpace, p1 ColorSpace) bool {
	c_p0 := p0.sk
	c_p1 := p1.sk
	retC := C.misk_ColorSpace_Equals(c_p0, c_p1)
	return bool(retC)
}

type FontMgr struct {
	sk *C.sk_SkFontMgr
}

/*
SkPaint controls options applied when drawing. SkPaint collects all
options outside of the SkCanvas clip and SkCanvas matrix.

Various options apply to strokes and fills, and images.

SkPaint collects effects and filters that describe single-pass and multiple-pass
algorithms that alter the drawing geometry, color, and transparency. For instance,
SkPaint does not directly implement dashing or blur, but contains the objects that do so.
*/
type Paint struct {
	sk *C.sk_SkPaint
}

/*
Constructs SkPaint with default values.

@return  default initialized SkPaint

example: https://fiddle.skia.org/c/@Paint_empty_constructor
*/
func NewPaint() Paint {

	retC := C.misk_new_Paint()
	return Paint{sk: retC}
}

/*
Makes a shallow copy of SkPaint. SkPathEffect, SkShader,
SkMaskFilter, SkColorFilter, and SkImageFilter are shared
between the original paint and the copy. Objects containing SkRefCnt increment
their references by one.

The referenced objects SkPathEffect, SkShader, SkMaskFilter, SkColorFilter,
and SkImageFilter cannot be modified after they are created.
This prevents objects with SkRefCnt from being modified once SkPaint refers to them.

@param paint  original to copy
@return       shallow copy of paint

example: https://fiddle.skia.org/c/@Paint_copy_const_SkPaint
*/
func NewPaintCopy(paint Paint) Paint {
	c_paint := paint.sk
	retC := C.misk_new_PaintCopy(c_paint)
	return Paint{sk: retC}
}

/*
Decreases SkPaint SkRefCnt of owned objects: SkPathEffect, SkShader,
SkMaskFilter, SkColorFilter, and SkImageFilter. If the
objects containing SkRefCnt go to zero, they are deleted.
*/
func (o Paint) Delete() {
	C.misk_delete_SkPaint(o.sk)
}

/*
Cap draws at the beginning and end of an open path contour.
*/
type PaintCap int64

const (
	// no stroke extension
	PaintCapButt PaintCap = 0
	// adds circle
	PaintCapRound PaintCap = 1
	// adds square
	PaintCapSquare PaintCap = 2
	// largest Cap value
	PaintCapLast PaintCap = 2
	// equivalent to kButt_Cap
	PaintCapDefault PaintCap = 0
)

/*
Join specifies how corners are drawn when a shape is stroked. Join
affects the four corners of a stroked rectangle, and the connected segments in a
stroked path.

Choose miter join to draw sharp corners. Choose round join to draw a circle with a
radius equal to the stroke width on top of the corner. Choose bevel join to minimally
connect the thick strokes.

The fill path constructed to describe the stroked path respects the join setting but may
not contain the actual join. For instance, a fill path constructed with round joins does
not necessarily include circles at each connected segment.
*/
type PaintJoin int64

const (
	// extends to miter limit
	PaintJoinMiter PaintJoin = 0
	// adds circle
	PaintJoinRound PaintJoin = 1
	// connects outside edges
	PaintJoinBevel PaintJoin = 2
	// equivalent to the largest value for Join
	PaintJoinLast PaintJoin = 2
	// equivalent to kMiter_Join
	PaintJoinDefault PaintJoin = 0
)

/*
Set Style to fill, stroke, or both fill and stroke geometry.
The stroke and fill
share all paint attributes; for instance, they are drawn with the same color.

Use kStrokeAndFill_Style to avoid hitting the same pixels twice with a stroke draw and
a fill draw.
*/
type PaintStyle int64

const (
	// set to fill geometry
	PaintStyleFill PaintStyle = 0
	// set to stroke geometry
	PaintStyleStroke PaintStyle = 1
	// sets to stroke and fill geometry
	PaintStyleStrokeAndFill PaintStyle = 2
)

/*
SkPath contain geometry. SkPath may be empty, or contain one or more verbs that
outline a figure. SkPath always starts with a move verb to a Cartesian coordinate,
and may be followed by additional verbs that add lines or curves.
Adding a close verb makes the geometry into a continuous loop, a closed contour.
SkPath may contain any number of contours, each beginning with a move verb.

SkPath contours may contain only a move verb, or may also contain lines,
quadratic beziers, conics, and cubic beziers. SkPath contours may be open or
closed.

When used to draw a filled area, SkPath describes whether the fill is inside or
outside the geometry. SkPath also describes the winding rule used to fill
overlapping contours.

Internally, SkPath lazily computes metrics likes bounds and convexity. Call
SkPath::updateBoundsCache to make SkPath thread safe.
*/
type Path struct {
	sk *C.sk_SkPath
}

/*
Constructs an empty SkPath. By default, SkPath has no verbs, no SkPoint, and no weights.
FillType is set to kWinding.

@return  empty SkPath

example: https://fiddle.skia.org/c/@Path_empty_constructor
*/
func NewPath() Path {

	retC := C.misk_new_Path()
	return Path{sk: retC}
}

/*
Constructs a copy of an existing path.
Copy constructor makes two paths identical by value. Internally, path and
the returned result share pointer values. The underlying verb array, SkPoint array
and weights are copied when modified.

Creating a SkPath copy is very efficient and never allocates memory.
SkPath are always copied by value from the interface; the underlying shared
pointers are not exposed.

@param path  SkPath to copy by value
@return      copy of SkPath

example: https://fiddle.skia.org/c/@Path_copy_const_SkPath
*/
func NewPathCopy(path Path) Path {
	c_path := path.sk
	retC := C.misk_new_PathCopy(c_path)
	return Path{sk: retC}
}

/*
Releases ownership of any shared data and deletes data if SkPath is sole owner.

example: https://fiddle.skia.org/c/@Path_destructor
*/
func (o Path) Delete() {
	C.misk_delete_SkPath(o.sk)
}

/*
AddPathMode chooses how addPath() appends. Adding one SkPath to another can extend
the last contour or start a new contour.
*/
type PathAddPathMode int64

const (
	/*
	   Contours are appended to the destination path as new contours.
	*/
	PathAddPathModeAppend PathAddPathMode = 0
	/*
	   Extends the last contour of the destination path with the first countour
	   of the source path, connecting them with a line.  If the last contour is
	   closed, a new empty contour starting at its start point is extended instead.
	   If the destination path is empty, the result is the source path.
	   The last path of the result is closed only if the last path of the source is.
	*/
	PathAddPathModeExtend PathAddPathMode = 1
)

/*
Four oval parts with radii (rx, ry) start at last SkPath SkPoint and ends at (x, y).
ArcSize and Direction select one of the four oval parts.
*/
type PathArcSize int64

const (
	// smaller of arc pair
	PathArcSizeSmall PathArcSize = 0
	// larger of arc pair
	PathArcSizeLarge PathArcSize = 1
)

/*
SegmentMask constants correspond to each drawing Verb type in SkPath; for
instance, if SkPath only contains lines, only the kLine_SegmentMask bit is set.
*/
type PathSegmentMask int64

const (
	PathSegmentMaskLine  PathSegmentMask = 1
	PathSegmentMaskQuad  PathSegmentMask = 2
	PathSegmentMaskConic PathSegmentMask = 4
	PathSegmentMaskCubic PathSegmentMask = 8
)

/*
Verb instructs SkPath how to interpret one or more SkPoint and optional conic weight;
manage contour, and terminate SkPath.
*/
type PathVerb int64

const (
	PathVerbMove  PathVerb = 0
	PathVerbLine  PathVerb = 1
	PathVerbQuad  PathVerb = 2
	PathVerbConic PathVerb = 3
	PathVerbCubic PathVerb = 4
	PathVerbClose PathVerb = 5
	PathVerbDone  PathVerb = 6
)

/*
Describes properties and constraints of a given SkSurface. The rendering engine can parse these
during drawing, and can sometimes optimize its performance (e.g. disabling an expensive
feature).
*/
type SurfaceProps struct {
	sk *C.sk_SkSurfaceProps
}

/*
No flags, unknown pixel geometry, platform-default contrast/gamma.
*/
func NewSurfaceProps() SurfaceProps {

	retC := C.misk_new_SurfaceProps()
	return SurfaceProps{sk: retC}
}

/*
TODO(kschmi): Remove this constructor and replace with the one below. *
*/
func NewSurfacePropsPixelGeometry(flags uint, p1 PixelGeometry) SurfaceProps {
	c_flags := C.uint(flags)
	c_p1 := C.uint(p1)
	retC := C.misk_new_SurfacePropsPixelGeometry(c_flags, c_p1)
	return SurfaceProps{sk: retC}
}

func NewSurfacePropsCopy(p0 SurfaceProps) SurfaceProps {
	c_p0 := p0.sk
	retC := C.misk_new_SurfacePropsCopy(c_p0)
	return SurfaceProps{sk: retC}
}

type SurfacePropsFlags int64

const (
	SurfacePropsFlagsDefault_Flag                   SurfacePropsFlags = 0
	SurfacePropsFlagsUseDeviceIndependentFonts_Flag SurfacePropsFlags = 1
	SurfacePropsFlagsDynamicMSAA_Flag               SurfacePropsFlags = 2
	SurfacePropsFlagsAlwaysDither_Flag              SurfacePropsFlags = 4
)

/*
\struct SkIRect
SkIRect holds four 32-bit integer coordinates describing the upper and
lower bounds of a rectangle. SkIRect may be created from outer bounds or
from position, width, and height. SkIRect describes an area; if its right
is less than or equal to its left, or if its bottom is less than or equal to
its top, it is considered empty.
*/
type IRect struct {
	sk *C.sk_SkIRect
}

/*
Returns constructed SkIRect set to (0, 0, 0, 0).
Many other rectangles are empty; if left is equal to or greater than right,
or if top is equal to or greater than bottom. Setting all members to zero
is a convenience, but does not designate a special empty rectangle.

@return  bounds (0, 0, 0, 0)
*/
func IRectMakeEmpty() IRect {

	retC := C.misk_IRect_MakeEmpty()
	return IRect{sk: &retC}
}

/*
Returns constructed SkIRect set to (l, t, r, b). Does not sort input; SkIRect may
result in fLeft greater than fRight, or fTop greater than fBottom.

@param l  integer stored in fLeft
@param t  integer stored in fTop
@param r  integer stored in fRight
@param b  integer stored in fBottom
@return   bounds (l, t, r, b)
*/
func IRectMakeLTRB(l int, t int, r int, b int) IRect {
	c_l := C.int(l)
	c_t := C.int(t)
	c_r := C.int(r)
	c_b := C.int(b)
	retC := C.misk_IRect_MakeLTRB(c_l, c_t, c_r, c_b)
	return IRect{sk: &retC}
}

/*
\struct SkRect
SkRect holds four float coordinates describing the upper and
lower bounds of a rectangle. SkRect may be created from outer bounds or
from position, width, and height. SkRect describes an area; if its right
is less than or equal to its left, or if its bottom is less than or equal to
its top, it is considered empty.
*/
type Rect struct {
	sk *C.sk_SkRect
}

/*
Returns constructed SkRect set to (0, 0, 0, 0).
Many other rectangles are empty; if left is equal to or greater than right,
or if top is equal to or greater than bottom. Setting all members to zero
is a convenience, but does not designate a special empty rectangle.

@return  bounds (0, 0, 0, 0)
*/
func RectMakeEmpty() Rect {

	retC := C.misk_Rect_MakeEmpty()
	return Rect{sk: &retC}
}

/*
Returns constructed SkRect set to (l, t, r, b). Does not sort input; SkRect may
result in fLeft greater than fRight, or fTop greater than fBottom.

@param l  float stored in fLeft
@param t  float stored in fTop
@param r  float stored in fRight
@param b  float stored in fBottom
@return   bounds (l, t, r, b)
*/
func RectMakeLTRB(l float32, t float32, r float32, b float32) Rect {
	c_l := C.float(l)
	c_t := C.float(t)
	c_r := C.float(r)
	c_b := C.float(b)
	retC := C.misk_Rect_MakeLTRB(c_l, c_t, c_r, c_b)
	return Rect{sk: &retC}
}

/*
Description of how the LCD strips are arranged for each pixel. If this is unknown, or the
pixels are meant to be "portable" and/or transformed before showing (e.g. rotated, scaled)
then use kUnknown_SkPixelGeometry.
*/
type PixelGeometry int64

const (
	PixelGeometryUnknown PixelGeometry = 0
	PixelGeometryRGB_H   PixelGeometry = 1
	PixelGeometryBGR_H   PixelGeometry = 2
	PixelGeometryRGB_V   PixelGeometry = 3
	PixelGeometryBGR_V   PixelGeometry = 4
)

func FontMgrRefDefault() FontMgr {
	return FontMgr{
		sk: C.sk_fontmgr_ref_default(),
	}
}
